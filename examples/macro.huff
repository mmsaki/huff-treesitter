#include "huffmate/utils/Errors.huff"
#define function addWord(uint256) pure returns (uint256)
#define function solution(uint256[2][2] calldata x, uint256[2][2] calldata y) pure returns (uint256[2][2] memory)

#define constant OWNER = FREE_STORAGE_POINTER()

#define event WordAdded(uint256 initial, uint256 increment)

#define macro emitWordAdded(increment) = takes (1) returns (0) {
    <increment>              // [increment, initial]
    __EVENT_HASH(WordAdded)  // [sig, increment, initial]
    0x00 0x00                // [mem_start, mem_end, sig, increment, initial]
    log3                     // []
}

#define macro ONLY_OWNER() = takes (0) returns (0) {
    caller                   // [msg.sender]
    [OWNER] sload            // [owner, msg.sender]
    eq                       // [owner == msg.sender]
    is_owner jumpi           // []
    0x00 0x00 revert
    is_owner:
}

#define macro ADD_WORD() = takes (1) returns (1) {
    ONLY_OWNER()
    dup1                     // [input_num, input_num]
    emitWordAdded(0x20)      // [input_num]
    0x20                     // [0x20, input_num]
    add                      // [0x20 + input_num]
}

#define macro MAIN() = takes (0) returns (0) {
    0x00 calldataload        // [calldata @ 0x00]
    0xE0 shr                 // [func_sig (calldata @ 0x00 >> 0xE0)]
    __FUNC_SIG(addWord)      // [func_sig(addWord), func_sig]
    eq                       // [func_sig(addWord) == func_sig]
    add_word jumpi           // []
    0x00 0x00 revert
    add_word:
        0x04 calldataload    // [input_num]
        ADD_WORD()           // [result]
        0x00 mstore          // []
        0x20 0x00 return
}

#[calldata("0x0000000000000000000000000000000000000000000000000000000000000001"), value(0x01)]
#define test MY_TEST() = {
    0x00 calldataload   // [0x01]
    callvalue           // [0x01, 0x01]
    eq ASSERT()
}
